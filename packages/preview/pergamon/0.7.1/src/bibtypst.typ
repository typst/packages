#import "@preview/bullseye:0.1.0": *
#import "@preview/oxifmt:1.0.0": strfmt
#import "@preview/citegeist:0.2.1": load-bibliography
#import "bib-util.typ": collect-deduplicate, fd
#import "names.typ": parse-reference-names
#import "dates.typ": parse-date, make-date-tuple

#let REFSECTION-END-MARKER = "refsection-end"

#let reference-collection = state("reference-collection", ())
#let bibliography = state("bibliography", (:))
#let current-citation-formatter = state("format-citation", (reference, form, options) => [CITATION], )
#let rendered-citation-count = state("rendered-citation-count", 0)
#let categories = state("categories", (:))

/// Parses #bibtex references and makes them available to #bibtypst.
/// Due to architectural limitations in Typst, #bibtypst cannot read 
/// #bibtex from a file. You will therefore typically call `read` yourself, like this:
/// #import "@preview/zebraw:0.5.5": *
/// #zebraw(lang: false,
/// ```typ
/// #add-bib-resource(read("bibliography.bib"))
/// ```
/// )
/// 
/// You can call `add-bib-resource` multiple times, and this will add
/// the contents of multiple bib files. However, all bibliography entries
/// must have different keys, even if they are in different source files.
/// 
/// -> none
#let add-bib-resource(
    /// A #bibtex string to be parsed.
    /// -> str
    bibtex-string,

    /// If `source-id` is not `none`, it is added to all references loaded from
    /// this #bibtex source under the `source-id` field. This can e.g. be used
    /// to filter bibliographies by source id.
    /// 
    /// For instance, this value of `filter` for @print-bibliography will only
    /// show the references that were assigned the source id `other.bib`:
    /// 
    /// ```
    /// filter: reference => reference.fields.at("source-id", default: none) == "other.bib"
    /// ```
    /// 
    /// -> str | none
    source-id: none
  ) = {
  bibliography.update(old-bib => {
    for (key, value) in load-bibliography(bibtex-string).pairs() {
      if key in old-bib {
        panic("Duplicate definition of bibliography key '" + key + "'.")
      }

      if source-id != none {
        value.fields.insert("source-id", source-id)
      }

      old-bib.insert(key, value)
    }

    old-bib
  })
}

/// Adds a category to the given bibliography entries.
/// The primary use of a category is in splitting bibliographies;
/// you could e.g. have one bibliography with highlighted references
/// and another one with the other references by adding some
/// references to a `"highlighted"` category. See the `has-category`
/// function for looking up categories.
/// 
/// Like in #biblatex, a category is defined globally for the
/// entire document, not per refsection. Calls to `add-category`
/// should come after the call to `add-bib-resource` that loaded
/// the references to which a category is assigned.
#let add-category(
  /// The category to which the keys should be assigned.
  /// -> str
  category, 

  /// The entry keys in the bibliography that should be assigned
  /// to the bibliography.
  /// -> arguments
  ..keys
) = {
  for key in keys.pos() {
    categories.update(cat-dict => {
      let cats = cat-dict.at(key, default: ())
      cats.push(category)
      cat-dict.insert(key, cats)
      cat-dict
    })
  }
}

/// Checks whether a bibliography entry has been assigned to the
/// given category. The primary purpose of this function is to be
/// used as a `filter` in `print-bibliography`.
/// 
/// The `key` argument can be a string; in this case it is interpreted
/// as the Bibtex key of a bibliography entry, and the function checks
/// whether this key has been assigned to the given `category`.
/// 
/// Alternatively, you can pass a reference dictionary as the `key`
/// argument. In this case, the function will check whether `key.entry_key`
/// has been assigned to the given category.
/// 
/// -> bool
#let has-category(
  /// The key that should be looked up.
  /// -> str | dict
  key,

  /// The category that should be checked.
  /// -> str
  category
) = {
  let kkey = if type(key) == dictionary and "entry_key" in key {
    key.entry_key
  } else {
    key
  }

  category in categories.get().at(kkey, default: ())
}

// Returns the current refsection identifier.
// 
// -> str
#let current-refsection() = {
  let refsection-count = reference-collection.get().len()
  "ref" + str(refsection-count)
}

// Prepends x with the current refsection identifier.
// Can be used to generate globally unique labels for references,
// even when they appear in multiple refsections.
// 
// -> str
#let refsectionize(x) = current-refsection() + "-" + x


/// Helper function for rendering the links to a bibliography entry.
/// The first argument is assumed to be a Typst #link("https://typst.app/docs/reference/model/link/")[link]
/// element, obtained e.g. as the argument of a show rule. If this `link` is a citation
/// pointing to a bibliography entry managed by Pergamon, e.g. generated by Pergamon's `cite` function,
/// the function passes the metadata
/// of this bib entry to the `citation-content` function and returns the content this
/// function generated. Otherwise, the `link` is passed to `other-content` for further processing.
/// 
/// The primary purpose of `if-citation` is to facilitate the definition of show rules.
/// A typical example is the following show rule, which colors references to my own publications
/// green and all others blue.
/// 
/// #zebraw(lang: false,
/// ```typ
/// #show link: it => if-citation(it, value => {
///    if "Koller" in family-names(value.reference.fields.parsed-author) {
///      set text(fill: green)
///      it
///    } else {
///      set text(fill: blue)
///      it
///  }})
/// ```)
/// 
/// -> content
#let if-citation(
    /// A Typst `link` element.
    /// -> link
    it, 

    /// A function that maps the metadata associated with a Pergamon reference to
    /// a piece of content. The metadata is a dictionary with keys `reference`, `index`, and
    /// `key`. `reference` is a reference dictionary (see @sec:reference),
    /// `key` is the key of the bib entry, and `index`
    /// is the position in the bibliography.
    /// 
    /// -> function
    citation-content, 

    /// A function that maps the `link` to a piece of content. The default argument
    /// simply leaves the `link` untouched, permitting other show rules to trigger and
    /// render it appropriately.
    /// -> function
    other-content: x => x
  ) = {
    if type(it.dest) == str or type(it.dest) == label {
      let lbl-name = str(it.dest)
      let targets = query(label(lbl-name))

      if targets != none and targets.len() > 0 {
        let meta = targets.first() // reference metadata
        if "value" in meta.fields() and type(meta.value) == dictionary and meta.value.at("kind", default: none) == "reference-data" {
          return citation-content(meta.value)
        }
      }
    }

    return other-content(it)
  }

/// Defines a section of the document with its own bibliography.
/// You need to load a bibliography with the @add-bib-resource function
/// in a place that is earlier than the refsection in rendering order.
/// 
/// Each refsection is automatically assigned a unique identifier that distinguishes
/// it from all other refsections in the document. These refsection identifiers are
/// used to generate unique Typst labels for all references in the document, even
/// when they represent the same Bibtex key. Users should make no assumptions about
/// the form of these identifiers beyond their uniqueness. Note that unlike in
/// #pergamon 0.6.0 and earlier, it is no longer possible to specify the refsection
/// identifier explicitly.
/// 
/// -> none
#let refsection(
  /// A function that generates the citation string for a list of references.
  /// The function receives an array of _citation specifications_ as its first
  /// argument, a `form` string as its second argument, and an `options` dictionary
  /// as its third argument. It returns
  /// the content that is displayed in place of a @cite call.
  /// 
  /// A citation specification is an array `(lbl, reference)`, where `lbl`
  /// is a citation label and `reference` is a reference dictionary.
  /// The citation formatter is expected to use the information in the reference
  /// dictionary to generate the citation and then embed it in a #link("https://typst.app/docs/reference/model/link/")[link] 
  /// to the given label (which is anchored by the reference in the bibliography).
  /// This might look like this:
  /// ```
  /// #link(label(lbl), format(reference))
  /// ```
  /// 
  /// In addition to `(lbl, reference)` pairs, the citation specification array
  /// can also contain elements that are strings (i.e. Typst objects of type `str`). 
  /// This happens in cases where the
  /// user cites a paper that does not exist in the bibliography. In this case,
  /// the string is the key of the cited paper, and the citation formatter is
  /// expected to render an appropriate error message. The builtin styles 
  /// render the key as "*?key?*"".
  /// 
  /// The `form` string specifies the exact form in which the citation is rendered;
  /// see @sec:builtin-citation-styles for details. This makes the difference e.g.
  /// between "Smith et al. (2025)" and "(Smith et al. 2025)".
  /// 
  /// The `options` dictionary specifies options that control the rendering of the
  /// citation in detail. For instance, the _authoryear_ style accepts 
  /// `prefix` and `suffix` arguments. Not every citation style is required to
  /// interpret the same options; see the documentation of the citation style
  /// for details.
  /// 
  /// The function you pass here will typically be defined in a #bibtypst citation style, to be
  /// compatible with the `format-reference` function that is passed to
  /// @print-bibliography.
  /// 
  /// You can pass `auto` in this argument to indicate that you want to use the
  /// same citation formatter as in the previous `refsection`. If you pass `auto`
  /// to the first refsection in the document, #bibtypst will use the dummy
  /// citation formatter `(references, form) => [CITATION]`.
  /// 
  /// -> function | auto
  format-citation: auto,

  /// The section of the document that is to be wrapped in this `refsection`.
  /// -> content
  doc) = {

  // Reset the keys that are cited in this section. Note that reference-collection
  // is an array of dictionaries, with one element per refsection in the document.
  // The last element of the array collects the references for the current refsection.
  reference-collection.update(rc => {
    rc.push((:))
    rc
  })

  // reset the count of rendered citations to zero
  rendered-citation-count.update(0)

  // update the citation formatter if one was specified
  if format-citation != auto {
    current-citation-formatter.update(it => format-citation)
  }

  context {
    // check that we have a bibliography loaded
    if bibliography.get() == none {
      panic("Add a bibliography before starting a refsection.")
    }
  }

  doc

  // Add a label at the end of the refsection, so that print-bibliography
  // can access the state of reference-collection at the end of the refsection.
  metadata((kind: REFSECTION-END-MARKER))
}

// Returns the metadata element at the end of the current refsection.
// The location() of this element can be used to retrieve the full set
// of references cited in the refsection, including ones that were only
// cited after the print-bibliography call.
// 
// -> metadata
#let find-refsection-end() = {
  let upcoming = query(selector(metadata).after(here()))
  let matching = upcoming.filter(m => {
    let v = m.value
    type(v) == dictionary and v.at("kind", default: none) == REFSECTION-END-MARKER
  })
  
  if matching.len() > 0 {
    matching.first()
  } else {
    none
  }
}

// Returns the set of all reference keys that were cited in the
// current refsection.
// 
// -> array
#let references-at-refsection-end() = {
  let loc = find-refsection-end().location()
  reference-collection.at(loc).last().keys()
}

/// Typesets a citation to the bibliography entry with the given keys.
/// The `cite` function keeps track of what `refsection` we are in and
/// uses that refsection's citation formatter to typeset the
/// citation.
/// 
/// You can pass a single key, `cite(key)`, to typeset a citation of a
/// single reference. Alternatively, you can pass multiple keys,
/// `cite(key1, key2, key3)`, to generate a sequence of citations. Depending
/// on the citation style, this may give you a compact and neat citation,
/// such as "[1, 5]" or "(Author 2020; Other 2021)".
/// 
/// Note that bib keys are always given as strings in #bibtypst,
/// e.g. `cite("paper1")`. This is in contrast to Typst's builtin cite function,
/// which expects labels.
/// 
/// You can pass a `form` for finer control over the citation string,
/// depending on what your citation style supports (see   @sec:builtin-citation-styles). If you do not specify
/// the `form`, its default value of `auto` will generate a default form
/// that depends on the citation style.
/// 
/// You can optionally pass a `prefix` or `suffix` argument to the `cite` call.
/// The authoryear style will place these before or after the main citation,
/// separated by its `prefix-separator` and `suffix-separator` parameters.
/// 
/// -> content
#let cite(
  /// The keys of the #bibtex entries you want to cite.
  /// 
  /// -> arguments
  ..keys,

  /// The citation form.
  /// 
  /// -> str | auto
  form: auto,
) = context {
  let format-citation = current-citation-formatter.get()
  let to-format = ()

  let xkeys = keys.pos()

  for key in xkeys {
    if type(key) != str {
      panic("Pergamon's cite function wants strings, but you passed " + str(type(key)) + ": " + str(key))
    }

    // collect individual citations
    reference-collection.update(rc => {
      rc.last().insert(key, 1)
      rc
    })

    // Render the citation.
    let lbl = refsectionize(key)
    let targets = query(label(lbl)) // find metadata object generated by print-bibliography
    if targets.len() == 0 {
      // on first pass, the label does not exist yet
      to-format.push(key)
    } else if "value" in targets.first().fields() { // not sure why I need this
      // on second pass, we can generate the real citation
      let value = targets.first().value
      // [|#value|]
      to-format.push((lbl, value))
    }
  }

  // call the citation formatter to typeset the citations
  format-citation(to-format, form, keys.named())
}

/// Typesets a citation with the form `"t"`, e.g. "Smith et al. (2020)".
/// See @cite for details.
#let citet(
  /// The keys of the #bibtex entries you want to cite.
  /// -> arguments
  ..keys
) = cite(..keys, form: "t")

/// Typesets a citation with the form `"p"`, e.g. "(Smith et al. 2020)".
/// See @cite for details.
#let citep(
  /// The keys of the #bibtex entries you want to cite.
  /// -> arguments
  ..keys
) = cite(..keys, form: "p")

/// Typesets a citation with the form `"g"`, e.g. "Smith et al.'s (2020)".
/// See @cite for details.
#let citeg(
  /// The keys of the #bibtex entries you want to cite.
  /// -> arguments
  ..keys
) = cite(..keys, form: "g")

/// Typesets a citation with the form `"n"`, e.g. "Smith et al. 2020".
/// See @cite for details.
#let citen(
  /// The keys of the #bibtex entries you want to cite.
  /// -> arguments
  ..keys
) = cite(..keys, form: "n")

/// Typesets a citation with the form `"name"`, e.g. "Smith et al.".
/// See @cite for details.
#let citename(
  /// The keys of the #bibtex entries you want to cite.
  /// -> arguments
  ..keys
) = cite(..keys, form: "name")

/// Typesets a citation with the form `"year"`, e.g. "2020a".
/// See @cite for details.
#let citeyear(
  /// The keys of the #bibtex entries you want to cite.
  /// -> arguments
  ..keys
) = cite(..keys, form: "year")


#let construct-sorting(sorting-string) = {
  let i = 0
  let ret = ()

  if sorting-string == "none" {
    return none
  }

  while i < sorting-string.len() {
    let sort-key = sorting-string.at(i)
    let sorting-function = if sort-key == "y" {
      // year
      let extract-date(reference) = {
        if reference.fields.parsed-date != none and "year" in reference.fields.parsed-date {
            reference.fields.parsed-date.year
        } else {
          0
        }
      }

      if i+1 < sorting-string.len() and sorting-string.at(i+1) == "d" {
        reference => -extract-date(reference)
        i += 1
      } else {
        reference => extract-date(reference)
      }
    } else if sort-key == "d" {
      // date
      let extract-date(reference, negate-year) = {
        if reference.fields.parsed-date != none {
          make-date-tuple(reference.fields.parsed-date, reversed: negate-year)
        } else {
          (0,0,0)
        }
      }

      if i+1 < sorting-string.len() and sorting-string.at(i+1) == "d" {
        reference => extract-date(reference, true)
        i += 1
      } else {
        reference => extract-date(reference, false)
      }
    } else if sort-key == "n" {
      // author name
      reference => reference.fields.sortstr // TEST ME
    } else if sort-key == "t" {
      // paper title
      reference => reference.fields.title.trim()
    } else if sort-key == "v" {
      // volume
      reference => if "volume" in reference.fields { reference.fields.volume } else { "ZZZZZZZZZZ" }
    } else if sort-key == "a" {
      reference => if "label" in reference { reference.label } else { "ZZZZZZZZZ" }
    } else {
      panic(strfmt("Sorting key {} is not implemented yet.", sort-key))
    }

    i += 1
    ret.push(sorting-function)
  }

  it => ret.map(f => f(it))
}

// Generate labels for the references, add extradates to distinguish them where
// necessary, and return the sorted bibliography.
#let label-sort-deduplicate(bibl-unsorted, label-generator, sorting-function, start-index) = {
  // Generate preliminary labels; note that the indices we pass to label-generator
  // are meaningless at this point, but they are guaranteed to be all different.
  for (index, reference) in bibl-unsorted.enumerate() {
    let (lbl, lbl-repr) = label-generator(start-index + index, reference)
    bibl-unsorted.at(index).insert("label", lbl)
    bibl-unsorted.at(index).insert("label-repr", lbl-repr)
  }

  // Sort and collect label collisions
  let sorted = bibl-unsorted.sorted(key: sorting-function)
  let sorted-labeled = sorted.enumerate().map(pair => (pair.at(1).at("label-repr"), pair.at(0)))
  let grouped = collect-deduplicate(sorted-labeled) // dict label-repr => list(reference-index)

  // Add extradates where needed
  for (lbl-repr, indices) in grouped {
    if indices.len() > 1 {
      let extradate = 0
      for ix in indices {
        sorted.at(ix).at("fields").insert("extradate", extradate)
        extradate += 1
      }
    }
  }

  // Generate final labels
  for (index, reference) in sorted.enumerate() {
    // call label-generator with meaningless indices, just in case it is needed
    let (lbl, lbl-repr) = label-generator(start-index + index, reference)
    sorted.at(index).insert("label", lbl)
    sorted.at(index).insert("label-repr", lbl-repr)
  }

  return sorted
}

// order in which sortstr fields are used for "n" sorting
#let namefield-sort-order = ("sortstr-sortname", "sortstr-author", "sortstr-editor", "sortstr-translator")

#let preprocess-reference(reference, name-fields, labelname-fields) = {
  let ref = parse-reference-names(reference, name-fields)

  // determine labelname
  let labelname-field = fd(ref, "labelnamefield", (:))
  if labelname-field != none {
    // if labelnamefield specified, try to populate labelname from it
    let parsed-fieldname = "parsed-" + labelname-field
    let value = fd(ref, parsed-fieldname, (:))
    if value != none {
      ref.fields.insert("labelname", value)
      ref.fields.insert("labelnamesource", labelname-field)
    }
  }

  if fd(ref, "labelname", (:)) == none {
    // if populating from labelnamefield didn't work, try the labelname-fields
    for fieldname in labelname-fields {
      let parsed-fieldname = "parsed-" + fieldname
      let value = fd(ref, parsed-fieldname, (:))
      if value != none {
        ref.fields.insert("labelname", value)
        ref.fields.insert("labelnamesource", fieldname)
        break
      }
    }
  }

  if fd(ref, "labelname", (:)) == none {
    panic("Could not determine labelname for bibliography key '" + reference.entry_key + "'")
  }

  // populate sortstr field (to be used in "n" sorting key)
  for fieldname in namefield-sort-order {
    let value = fd(ref, fieldname, (:))
    if value != none {
      ref.fields.insert("sortstr", value)
      break
    }
  }

  // definitely parse "date" field with fallback "year"
  let parsed-date = parse-date(reference, "date", fallback-year-field: "year", fallback-month-field: "month")
  ref.fields.insert("parsed-date", parsed-date)

  // if other "Xdate" fields are defined, parse them too
  for field-name in reference.fields.keys() {
    if field-name.ends-with("date") and field-name != "date" {
      let parsed-date = parse-date(reference, field-name)
      ref.fields.insert("parsed-" + field-name, parsed-date)
    }
  }

  ref
}


/// Prints the bibliography for the @refsection in which it is contained.
/// This function cannot be used outside of a refsection.
///
/// -> none
#let print-bibliography( 
    /// A function that renders the reference into Typst content, which will
    /// then be included  in the
    /// printed bibliography. This function will typically be defined
    /// in a #bibtypst style, to be compatible with the `format-citation`
    /// function that is passed to @refsection.
    /// 
    /// `format-reference` is passed the position of the reference in the
    /// bibliography as a zero-based `int` in the first argument.
    /// It is passed the #link(<sec:reference>)[reference dictionary]
    /// for the reference
    /// in the second argument.
    /// 
    /// It returns an
    /// array of contents. The elements of this array will be laid out as the columns
    /// of a grid, in the same row, permitting e.g. bibliography layouts with one
    /// column for the reference label and one with the reference itself. 
    /// If only one column is needed (e.g. in the authoryear citation style),
    /// `format-reference` should return an array of length one.
    /// All calls to `format-reference` should return arrays of the same length.
    /// 
    /// -> function
    format-reference: (index, reference) => ([REFERENCE],),

    /// Generates label information for the given reference. The function takes
    /// the reference dictionary and the reference's index in the sorted bibliography as input and returns
    /// an array `(label, label-repr)`, where `label` can be anything the style finds
    /// useful for generating the citations and `label-repr` is a string representation
    /// of the label. These string representations are used to detect label collisions,
    /// which cause the generation of extradates.
    /// 
    /// The default implementation simply returns a number that is guaranteed to be
    /// unique to each reference. Styles that want to work with `extradate` will almost
    /// certainly want to pass a different function here.
    /// 
    /// The function passed as `label-generator` does not control whether labels
    /// are printed in the bibliography in their own separate column; it only computes information for internal use.
    /// A style can decide whether it wants to print labels through its `format-reference`
    /// function.
    /// 
    /// Note that `label-repr` _must_ be a `str`.
    /// 
    /// -> function
    label-generator: (index, reference) => (index + 1, str(index + 1)),

    /// A function that defines the order in which references are shown in the bibliography.
    /// This function takes a #link(<sec:reference>)[reference dictionary] as input and returns a value that can be 
    /// #link("https://typst.app/docs/reference/foundations/array/#definitions-sorted")[sorted],
    /// e.g. a number, a string, or an array of sortable values.
    /// 
    /// Alternatively, you can specify a #biblatex\-style sorting string. The following strings are
    /// supported:
    /// - `n`: author name (lastname firstname)
    /// - `t`: paper title
    /// - `y`: the year in which the paper was published; write `yd` for descending order
    /// - `d`: the date on which the paper was published; write `dd` for descending order
    /// - `v`: volume, if defined
    /// - `a`: the contents of the `label` field (if defined); for the `alphabetic` style, this amounts to the alphabetic paper key
    /// 
    /// For instance, `"nydt"` sorts the references first by author name, then by descending year, then by title.
    /// 
    /// See @sec:dates for details on how dates are parsed in the #bibtex entries. If
    /// a field of the date (year, month, day) is missing, it is treated as zero for the purposes
    /// of sorting. Months that are specified as strings (e.g. `"July"` rather than `7` or `jul`)
    /// are also treated as zero.
    /// 
    /// If `none` or the string `"none"` is passed as the `sorting` argument, the references
    /// are sorted in an arbitrary order. There is currently no reliable support for sorting
    /// the references in the order in which they were cited in the document.
    /// 
    /// -> function | str | none
    sorting: none,

    /// Determines whether the printed bibliography should contains all references from the loaded bibliographies
    /// (`true`) or only those that were cited in the current refsection (`false`).
    /// -> bool
    show-all: false,

    /// Filters which references should be included in the printed bibliography. This makes sense only if
    /// `show-all` is `true`, otherwise not all your citations will be resolved to bibliography entries.
    /// The parameter should be a function that takes a #link(<sec:reference>)[reference dictionary] as argument
    /// and returns a boolean value. The printed bibliography will contain exactly those references
    /// for which the function returned `true`.
    /// -> function
    /// 
    filter: reference => true,

    /// A dictionary for styling the #link("https://typst.app/docs/reference/layout/grid/")[grid]
    /// in which the bibliography is laid out. By default, the grid is laid out with `row-gutter: 1.2em` and
    /// `column-gutter: 0.5em`. You can overwrite these values and specify new ones with this argument;
    /// the revised style specification will be passed to the `grid` function.
    /// 
    /// -> dictionary
    grid-style: (:),

    /// The title that will be typeset above the bibliography in the document.
    /// The string given here will be rendered as a first-level heading without numbering.
    /// Pass `none` to suppress the bibliography title.
    /// 
    /// -> str | content | none
    title: "References",

    /// Whether the title of the bibliography should appear in the document's #link("https://typst.app/docs/reference/model/outline/")[outline].
    /// 
    /// -> bool
    outlined: true,

    /// #bibtex fields that contain names and should be parsed as such. For each `X` in this array,
    /// #bibtypst will enrich the reference dictionary with a field `parsed-X` that contains an array of
    /// name-part dictionaries, such as `("family": "Smith", "given": "John")`. See
    /// @sec:reference for an example.
    /// 
    /// If the field `X` is not defined in the #bibtex entry, #bibtypst will still insert
    /// a field `parsed-X`; in this case, it will have the value `none`.
    /// 
    /// Note that to fully replicate the options `useauthor` / `useeditor` / `usetranslator`
    /// in #biblatex, you will need to both (a) specify the corresponding option in @format-reference
    /// and (b) remove the field from the `name-fields` parameter here. This is because
    /// `name-fields` is used to determine the reference's `labelname`, long before `format-reference`
    /// gets to typeset the reference itself. 
    /// 
    /// -> array
    name-fields: ("afterword",
        "annotator",
        "author",
        "bookauthor",
        "commentator",
        "editor",
        "editora",
        "editorb",
        "editorc",
        "foreword",
        "holder",
        "introduction",
        "shortauthor",
        "shorteditor",
        "sortname",
        "translator"),

    /// #bibtex fields that will be considered when determining the entry's labelname.
    /// The labelname is the field that will be used when generating the labels for
    /// the _authoryear_ and _alphabetic_ citation styles. Labelnames are computed as follows:
    /// 
    /// - If the #bibtex entry specified a field with the name `labelnamefield`, then the
    ///   #bibtex field specified under `labelnamefield` is used.
    /// - Otherwise, the first field name in `labelname-fields` that is defined in the
    ///   #bibtex entry is used.
    /// - If none of these fields is defined, #pergamon will throw an error.
    ///   
    /// In either of these cases, the name of the #bibtex field from which the labelname
    /// is taken is stored in the #bibtex field `labelnamesource`.
    /// 
    /// #pergamon assumes that the labelname field contains a list of names.
    /// 
    /// -> array
    labelname-fields: (
      "shortauthor",
      "author",
      "shorteditor",
      "editor",
      "translator"
    ),

    /// Starts the numbering of entries in this bibliography after the number
    /// specified in this argument. Let's say you typeset two bibliographies in
    /// your document, and the first one has 15 entries. You can pass `15` in 
    /// the `resume-after` argument to make the numbering of entries in the second
    /// bibliography start at 16.
    /// 
    /// The `index` parameters of functions like `format-reference` and `format-citation`
    /// will receive the sum of resume-after and the actual position in this particular
    /// bibliography as an argument. In the example above, the first reference in the
    /// second bibliography will be called with index=15 (because the count in the
    /// second bibliography is zero-based). The only default citation style that cares
    /// about indices is _numeric_.
    /// 
    /// If you have
    /// multiple calls to `print-bibliography` within the same `refsection`, 
    /// you can pass `auto` to `resume-after` to seamlessly continue the numbering
    /// across bibliographies within the same refsection. Note that this requires
    /// slightly complex state management, and using the `auto` argument will
    /// require Typst to perform four iterations to make the layout converge
    /// (rather than three for other uses of Pergamon).
    /// 
    /// -> int | auto
    resume-after: 0,

    /// Prints the bibliography in reverse order. This does not change the
    /// numbering of the references -- e.g. in the numeric style, the first
    /// reference in the order of the `sorting` order is still called "[1]".
    /// However, if `reversed` is set to `true`, the reference [1] will be
    /// the final reference in the bibliography.
    /// 
    /// -> bool
    reversed: false
  ) = context {

  let start-index = if resume-after == auto { rendered-citation-count.get() } else { resume-after }
  let bib = bibliography.get()

  // construct sorting function if necessary
  let sorting-function = if type(sorting) == str { construct-sorting(sorting) } else { sorting }
  if sorting-function == none {
    sorting-function = it => 0
  }

  // extract references for the cited keys
  let bibl-unsorted = ()
  let count-references = 0

  if show-all {
    for reference in bib.values() {
      let ref = preprocess-reference(reference, name-fields, labelname-fields)
      bibl-unsorted.push(ref)
    }
  } else {
    let cited-keys = references-at-refsection-end()
    for key in cited-keys {
      if key in bib { // skip references to labels that are not bib keys
        let bib-entry = bib.at(key)
        bib-entry = preprocess-reference(bib-entry, name-fields, labelname-fields)
        bibl-unsorted.push(bib-entry)
      }
    }
  }

  bibl-unsorted = bibl-unsorted.filter(filter)
  let sorted = label-sort-deduplicate(bibl-unsorted, label-generator, sorting-function, start-index)
  let n = sorted.len()
  let formatted-references-original = sorted.enumerate(start: start-index).map(it => format-reference(it.at(0), it.at(1)))
  // -> array(array(content))
  
  let formatted-references = if reversed {
    formatted-references-original.rev()
  } else {
    formatted-references-original
  }
  
  let num-columns = if formatted-references.len() == 0 { 0 } else { formatted-references.at(0).len() }
  let cells = ()

  rendered-citation-count.update(x => x + n)

  // collect cells
  for index in range(sorted.len()) {
    let reference = sorted.at(index)
    let formatted-reference = formatted-references.at(index)

    // construct first cell of the row, it has to contain the metadata and label
    let meta = (
      kind: "reference-data",
      key: reference.entry_key,
      index: start-index + index,
      reference: reference,
    )

    // store the data in "meta" in a metadata element, so it can later be access through the label
    let lbl = refsectionize(reference.entry_key)
    let cell0 = [
      #metadata(meta)#label(lbl)#formatted-reference.at(0)
      // Use this to debug #95
      // #linebreak()#repr(formatted-reference)
    ]
    cells.push(cell0)

    // add all the other cells, if any
    for cell in formatted-reference.slice(1) {
      cells.push(cell)
    }
  }

  // "References" heading
  if title != none {
    match-target(
      paged: heading(title, numbering: none, outlined: outlined),
      html: html.elem("h2", attrs: (class: "reference-heading"), title)
    )
  }

  // layout the cells in a grid
  let alignment = if num-columns > 1 { (right, left) } else { (left,) }
  if num-columns > 0 {
    // allow grid-style argument to override default layout parameters
    let final-grid-style = (columns: num-columns, align: alignment, row-gutter: 1.2em, column-gutter: 0.8em, stroke: none)
    for (key, value) in grid-style.pairs() {
      final-grid-style.insert(key, value)
    }

    match-target(
      paged: grid(..final-grid-style, ..cells),
      html: table(columns: num-columns, ..cells)
    )
  } else {
    []
  }
}
