#import "template.typ" as tmp: *

#let render-code(txt) = {
  eval(mode: "markup", txt.text, scope: dictionary(tmp))
}
#let render-result(txt, title: auto) = {
  show-results(render-code(txt), title: {
    if title == auto {
      [on subslide ] + context store.states.get().at(0).subslide
    } else { title }
  })
}
#show: config
#set-options(handout: false, freeze-states: true)

// The contents

#heading(numbering: none, outlined: false)[Outline]

#slide[
  #outline(title: none)
]


= Introduction

#slide[Presentation by Coding?][
  #utils.multicols(2)[
    #cetz.canvas({
      import cetz.draw: *
      import "@preview/cetz-plot:0.1.2": *
      plot.plot(
        name: "p",
        size: (4, 4),
        x-tick-step: 1,
        y-tick-step: 4,
        plot.add(domain: (0, 4), x => x * x, style: (stroke: 2pt + eastern)),
      )
      group(anchor: "north", padding: (top: 0.5), {
        fill(eastern.lighten(50%))
        stroke(none)
        anchor("default", "p.south")
        set-origin("p.south")
        circle((0, 0), name: "C")
        fill(eastern.lighten(30%))
        rect((to: "C.east", rel: (0, .5)), (rel: (1.8, 1.8)), name: "R")
        fill(eastern)
        polygon((to: "R.east", rel: (.5, -2)), 3, radius: 1.2, angle: -30deg)
      })
    })

  ][
    Presentation's objective is to convey information to the audiences.
    *Slide deck* is one of visual media we can use for such tasks.

    #show: pause

    Often, using visual tools is easy, as you can modify what you want.
    However, we have to admit that sometimes creating visual media is _easier in code_.

    #show: pause

    Imagine creating visual graphs that update directly from your source project.

    #show: pause

    So you #alert[don't have to update them manually].
  ]
]

#slide[A note about animating PDFs][
  Creating presentation in Typst, especially in PDF format, cannot provide the _actual animated_ scenes like videos.
  #show: pause

  However, the _dynamic_ contents on the following examples are generated by _repeatedly printed_ each page, which contains slightly different components.\
  #show: pause
  #figure(image("example0.png", width: 100%))
  So that when you see on the screen,  it _looks like_ the contents are changing.
]

#slide[Integration of Tools][

  *Presentate* is another package written in Typst for creating slides.

  #show: pause

  We already have other powerful presentation packages! So it rises a question:

  #show: pause

  _Why creating another?_

  #show: pause
  The answer is *Package Integrations*.


]



#slide[
  #utils.multicols((1fr, 1fr))[

    Slide animation requires information in type `content`; however, most packages for creating visual data output requires #emph[non-`content`] input, such as

    #fragments(hider: utils.hide-enum-list)[

      - CeTZ: arrays of functions
    ][

      - Fletcher: special metadata
    ][

      - Alchemist: arrays of dictionary
    ]
  ][
    #show: pause

    #figure(diagram(
      $
        #[input] edge(->) & #emph[hide function] edge(->, "d") \
                #[output] & edge(->, "l") #[process by packages]
      $,
    ))
    #show: pause

    So to create animation with those packages, we need some functionality to be able to _hide_ the information _without_ `content` generation.
  ]
]

#slide[
  Here is when presentate comes in. #show: pause

  Presentate provides a framework for rendering input and output of _any kind_.

  Like the following molecule drawing animation from #footlink("https://typst.app/universe/package/alchemist")[Alchemist] package:

  #import "@preview/alchemist:0.1.6" as alc
  #{
    let modifier(func, ..args) = func(stroke: none, ..args) // set stroke to `none`
    let (single, double) = animation.animate(modifier: modifier, alc.single, alc.double)
    let (fragment,) = animation.animate(modifier: (func, ..args) => none, alc.fragment)  // hide the atoms

    utils.multicols(
      (1fr, 1fr),
      align: center,
      render(s => (
        {
          alc.skeletize({
            fragment(s, "H_3C")
            s.push(auto)
            single(s, angle: 1)
            fragment(s, "CH_2")
            s.push(auto)
            single(s, angle: -1, from: 0)
            fragment(s, "CH_2")
            s.push(auto)
            single(s, from: 0, angle: 1)
            fragment(s, "CH_3")
          })
        },
        s,
      )),
      render(s => (
        {
          alc.skeletize(config: (atom-sep: 2.5em), {
            alc.cycle(6, {
              single(s)
              double(s)
              alc.branch({
                s.push(auto)
                single(s)
                s.push(auto)
                fragment(s, "NO_2")
              })
              s.push(7)
              single(s)
              double(s)
              single(s)
              double(s)
            })
          })
        },
        s,
      )),
    )
  }
]

#slide[About Presentate][
  *Presentate* is a package aimimg to provide a _framework_ for creating dynamic presentation animations that are _flexible_ enough to be used with any packages.

  #show: pause

  The package provides:


  #utils.multicols((1fr, 1fr), align: top)[
    #animate-items[
      - revealing content step-by-step from `#show: pause`,

    ][
      - revealing content specifically from
        `#uncover(..)` and `#only(..)`,
    ]
  ][
    #animate-items[
      - transform content by `#transform(..)` ,

    ][
      - relative index like `#auto` and `#none`,

    ][
      - render frame for package integration, with `#animation` module.
    ]
  ]
]



#slide[Acknowledgement][

  The package was created by mixing my original motivation and insprations from many existing presentation packages.

  Thanks to:
  #footlink("https://github.com/polylux-typ/polylux", [Polylux]) for  `subslide` implementation and pdfpc support, \
  #footlink("https://github.com/touying-typ/touying")[Touying] for idea of render frame, fake frozen states, and \
  #footlink("https://github.com/knuesel/typst-minideck")[Minideck] for `#only`, and `#uncover` functions.
]


= Usage


#slide[Getting Started][
  Start with the following snippets:
  ```typ
  #import "@preview/presentate:0.2.0": *
  #set text(size: 25pt) // of your choice

  #slide[
    Hello World!
    #show: pause;

    This is `presentate`.
  ]
  ```


]

#slide[
  Then you will have:
  #image("example1.png")
]

#slide[
  You may styling the way you want, for example:
  ```
  #import "@submit/presentate:0.2.0": *
  #set page(paper: "presentation-16-9")
  #set text(size: 25pt, font: "FiraCode Nerd Font Mono")
  #set align(horizon)
  #slide[
    = Welcome to Presentate!
    \ A lazy author \
    #datetime.today().display()
  ]
  ```<codly-ex2-1>





]

#slide[
  #show: columns.with(2)
  (continued)
  #codly(offset-from: <codly-ex2-1>)
  ```
  #set align(top)
  #slide[
    == Tips for Typst.
    #set align(horizon)
    Do you know that $pi != 3.141592$?

    #show: pause
    Yeah. Certainly.

    #show: pause
    Also $pi != 22/7$.
  ]
  ```
  #show: pause

  Presentate does not interfere Typst styling systems, so you can set and un-set anything freely.

  The results are on the next slide:
]

#slide[
  #figure(image("example2.png", height: 80%))
]




#slide[Dynamic Components][
  `#slide[..]` function provides a workspace for creating _animations_ . \
  As the example showing the use of `#show: pause` functionality.

  #show: pause

  Presentate provides the following functions for creating dynamic slides:

  #animate-items[
    + `#pause(..)` for basic reveal of content in chunks.

  ][
    + `#uncover(..)` and `#only(..)`  for precise steps of revealing content.
  ][
    + `#fragments(..)` for revealing content one-by-one.
  ][
    + `#transform(..)` for transform the content by functions.
  ][
    + `#render(..)` and `#animate(..)` for handling non-content type data.
  ]
]

#slide[`#pause` function][
  Basic usage of `#pause(..)` is usually in the form `#show: pause`. \
  Apart from that, you can put any content in the `(..)`, e.g. math equations.

  #show: pause

  #let src = (
    ```
    $ (x + y)^2 pause(&= (x + y)(x + y)) \
                pause(&= x^2 + 2 x y + y^2) $
    ```
  )
  #render-code(src)
  #show: pause
  as from
  #src

]

#slide[`#fragments` function][
  #utils.multicols((1fr, 1fr), align: top)[
    Imagine having to type
    ```
    #pause[+ A]
    #pause[+ B]
    #pause[+ C]
    ```
    to reveal `A` to `C` consecutively; #show: pause; however,\
    we have a better way.
  ][
    #show: pause
    Indroducing `#fragments(..)`:

    #let src = (
      ```
      #fragments[+ A][+ B][+ C]
      ```
    )
    #src
    #show: pause
    #show-results(render-code(src))
  ]
  #show: pause

  *Note:* default `#hide` function cannot hide the number or list markers.\
  To solve this, we will introduce the alternative way to 'hide' them.


]

#slide[The `#hider` argument][
  Every function that can 'hide' and reveal content has a named argument called `#hider`. This argument has a default value of Typst's native `#hide()` function.

  #show: pause

  However, this `#hide()` function cannot hide list and enum's markers effectively, as seen in the previous example (and actually can be changed to suit with your type).

  #show: pause
  We can hack using a new hider: `#utils.hide-enum-list()` function from the `#utils` module of our package. For example:
]


#slide[
  #codly(highlighted-lines: (2,))
  #let src = ```
  #fragments(
    hider: utils.hide-enum-list
  )[
    + A // space around is needed.

  ][+ B][+ C]
  ```
  #utils.multicols((1fr, 1fr), align: top)[
    #src
  ][
    #show-results(render-code(src))
  ]
  #show: pause
  *Warning!* This hider _will affect_ the layout if the list is `#tight`,
  so, new lines are needed to make it _non-tight_, and it _cannot be nested_.

  This function is useful for both `#enum.item` and `#list.item`.
]



#slide[`#only` and `#uncover`][
  So far, `#pause` and `#fragments` examples only show you to reveal the content _step-by-step_. How about _absolutely_ reveal content? Say, at a given number of frames?

  #show: pause

  #gtc.clue[
    A *frame* or *subslide* is a page that contains fragments of slides' content, so that when all pages are viewed consecutively, we can see the _change_ of content.
  ]

  #show: pause

  For a more complex animation, `#only` and `#uncover` functions can control when the content will be shown based on given number of frames, or _subslide number_.

]

#slide[
  #let src = ```
  Content Before

  #only(2, 4)[
    This is _only_ shown on subslide 2 and 4.
  ]

  Content After
  ```

  #utils.multicols((1fr, 1fr))[
    #src
  ][
    #show-results(render-code(src), title: [on subslide #context store.states.get().at(0).subslide])
  ]
  #show: pause
  `#only(..n, body)` shows the `#body` _only_ at the given subslide numbers `#n`. \ For other frames, the content is vanished, with no preserved space.
]

#slide[
  #let src = ```
  Content Before

  #uncover(2, from: 4)[
    This is _uncovered_ on subslide 2 and 4 onwards.
  ]

  Content After
  ```
  #utils.multicols((1fr, 1fr))[
    #src
  ][
    #show-results(render-code(src), title: [on subslide #context store.states.get().at(0).subslide])
  ]
  #show: pause
  `#uncover(..n, from: int, body)` uncovers the `#body` in the same condition as `#only`, with an exception of having _space preserved_.
]

#slide[
  If you noticed the last example carefully, you will see the argument `#from` being introduced in the `#uncover(from: int, ..)`.

  #show: pause

  Both `#only` and `#uncover` can take the `#from` as integer to start revealing the content only after that subslide number `#from`.

  #show: pause
  _Not only integers_ can you use as subslide number, `#auto` and `#none` also can be used. What do they do?
]

#slide[Relative Indices][
  If you want to reveal a yellow box once in a frame after some stream of content, say the following code:
  #let src = ```
  Content #show: pause; Content

  #uncover(3, rect(
    fill: yellow, [BOX]
  ))
  ```
  #utils.multicols((1fr, 1fr))[
    #src
  ][
    #render-result(src)
  ]
  #show: pause
  You must know the current number of `#pause`s to determine the subslide number where the `BOX` must be shown. #show: pause; Is there an alternative? _Yes: Relative Indices_
]

#slide[
  #gtc.clue[
    *Index* (plural: Indices) is subslide number.
  ]
  Index specified in `#uncover`, `#only`, and other arguments that requires it has 2 types:

  #set enum(numbering: n => {
    uncover(update-pause: false, from: auto, numbering("1.", n))
  })

  + #show: pause; *Absolute* index: the actual integer subslide number, and

  + #show: pause;
    *Relative* index: `#auto` and `#none`, relative to _number of pauses_

    #animate-items[
      - `#auto` means index _after_ the current number of pauses.

    ][
      - `#none` means index _as same as_ the current number of pauses.
    ]


]

#slide[
  *Example:* Uncover the yellow box on subslide 5 and after current pauses state, together with only show X on the same subslide as the current pauses.
  #let src = ```
  Content #show: pause; Content

  #uncover(auto, 5, rect(
    fill: yellow, [BOX]
  ))

  After Content #only(none, [X])
  ```

  #utils.multicols((1fr, 1fr))[
    #codly(highlighted-lines: (3, 7))
    #src
  ][
    #render-result(src)
  ]

]

#slide[Varying Timeline][
  If you look at the last example carefully, it is noticeable that when `After Content` appears, it follows the `#show: pause` function, as if there where no `#uncover` in between.

  #show: pause

  However, what if we want to reveal some content afterwards, after every animation, without the need of specifying the subslide number?

  #show: pause

  If only the `#pause` 'sees' the `#uncover`'s presence, it would be good, right?

  _Yes, it can_, by set the argument `#uncover(update-pause: true)`.

]

#slide[
  *Example:* The yellow box is revealed on subslide 5 and after the current pauses, with `After Content` appears after every animation.
  #let src = ```
  Content #show: pause; Content

  #uncover(auto, 5, rect(
    fill: yellow, [BOX]
  ), update-pause: true)

  #pause[After Content]
  ```

  #utils.multicols((1fr, 1fr))[
    #codly(highlighted-lines: (5,))
    #src
  ][
    #render-result(src)
  ]
]

#slide[
  `#update-pause` argument updates the current pauses to the maxium index. In the example, `#auto` resolves to 3, so 5 is the maximum.
  #show: pause

  Both `#only` and `#uncover` have `#update-pause` argument, but they are set to be `#false` by default. So these functions reveal the content _independently_ from `#pause(..)`.

  #show: pause

  However, the ability to affect the `#pause(..)`  progress unlocks one powerful key:

  #show: pause

  *Number of pauses can be varied and independent from actual number of `#pause`s*.

  If we use `#only` or `#uncover` to change them, for example:
]

#slide[
  Content can be revealed parallel on side by side.
  #let src = ```
  #grid(columns: (1fr, 1fr))[
    First \ #show: pause;
    A #show: pause; B
  ][ // `[]` is a dummy content.
    #uncover(1, [], update-pause: true)
    Second \ #show: pause;
    A #show: pause; B
  ]
  ```
  #utils.multicols((55%, 1fr))[
    #codly(highlighted-lines: (5,))
    #src
  ][
    #render-result(src)
    The content on both columns are shown synchronously, because the pauses are _set_ to 1 (first subslide) by `#uncover`.
  ]
]

#slide[Animated Decorations][
  Most of the functions we provide up until now can only create animations of hiding and showing stuff. How about _changing_ its appearance? e.g. color?

  #show: pause
  You can #alert[emphasize] your words by using `#alert` like in this sentence. \
  `#alert` can #alert[alert] the audience by wrapping the input with its `#func` argument,\  which is `#emph` function by default.

  #show: pause
  #let src = ```
  Please #alert[FOCUS] me
  and #alert(
    func: text.with(fill: red), [Warn]
  ) them.
  ```
  #utils.multicols((70%, 1fr))[
    #src
  ][
    #render-result(src, title: [])
  ]
]

#slide[
  Another functions for creating multiple _alerts_ is called `#transform`. \
  This function wraps the content and change its through a series of functions.

  #show: pause
  This is very useful for creating step-by-step list alerts or make the content dynamically changing its appearance. For example,
  #let src = ```
  #let no(body) = body // original apperance
  #let yes(body) = text(fill: red, body)
  #transform([- First Item], yes, no)
  #transform(start: none, [- Second Item], yes, no)
  #transform(start: none, [- Third Item], yes, no)
  ```
  #utils.multicols((71%, 1fr))[
    #src
  ][
    #render-result(src, title: [])
  ]
]

#slide[

  #let src = ````
  #transform(
    codly(highlighted-lines: (1,)),
    codly(highlighted-lines: (4,)) )
  ```python
  n = input("Number: ")
  n = int(n)
  for i in range(n):
    print("Hello World!")
  ```
  ````
  #utils.multicols((55%, 1fr))[
    #src
  ][
    You can use this to highlight different lines of code with #footlink("https://typst.app/universe/package/codly/")[Codly].
    #render-result(src)
  ]
]

#slide[Rendering Stuffs][
  Here comes the most powerful, but most complex utilization of Presentate:
  `#render` function and `#animation` module.

  #show: pause
  As we have told, package integration on presentation animation is sometimes tricky, as they are not happy with #mnt.dtype("content") input data.

  #show: pause
  So presentate provides a _workspace_ for rendering stuffs that are not necessary to be in content type, with _non-content updates_ for number of frames needed.
  #show: pause

  So you can focus on the animation, without worrying about number of subslides.
]

#slide[
  *Structure of `#render`*

  #let src = ```
  #render(s => ({
    import animation: *
    // your stuff goes here.
  }, s))
  ```
  #utils.multicols((1fr, 1fr))[
    #src
    #show: pause
    `#render` only accepts one positional argument: *a function*.

  ][
    #show: pause
    This function accepts the current animation states,
    and returns _an array_, of length 2 which

    - *first* member is the shown output,
    - *second* member is the updated states.
  ]
  #show: pause
  This way, Presentate can both show your output, and update the states, so the other elements on the slide react automatically.

]

#slide[
  The first member's area only accepts #mnt.dtype("content"), intended for updating internal states.

  However, to create animation with `#render` without generating #mnt.dtype("content") during the way, Presentate provides the same set of functionality like `#pause`, `#only`, `#fragments`, `#alert`, `#uncover`, and so on, with some key differences:

  #animate-items[
    + These functions must be imported from `#animation` module.
  ][
    + The functions will always accepts the _state_ (`#s`) as first positional argument.
  ][
    + *You have to update the state variable (`#s`) manually*.
  ]
]

#let src1 = ```
#import "@preview/cetz:0.4.1": canvas, draw
#render(s => ({
  import animation: *
  canvas({
    import draw: *
    pause(s, circle((0, 0), fill: green,))
    s.push(auto) // update s
    pause(s, circle((1, 0), fill: red))
  })
}, s))
```
#let src2 = ```
#import "@preview/cetz:0.4.1": canvas, draw
  #render(s => ({
    import animation: *
    let (pause,) = settings(hider: draw.hide.with(bounds: true))
    canvas({
      import draw: *
      pause(s, circle((0, 0), fill: green,))
      s.push(auto) // update s
      pause(s, circle((1, 0), fill: red))
    })
  }, s))
```
#slide[
  *Example 1*: Animated #footlink("https://typst.app/universe/package/cetz", [CeTZ]) diagram. Create an animation drawing two circles, in green and red.

  #columns(2, src1)
]

#slide[
  #utils.multicols((1fr, 1fr))[
    #render-result(src1)
  ][
    #set raw(lang: "typc")
    #show: pause
    The default hider of `animation.pause` is
    `it => none`, so it _does not_ preserve space.
  ]
  #show: pause
  However, you can change this by the `#draw.hide.with(bounds: true)` from native CeTZ to preserve space, by adding the following line before `#canvas`:

  ```typc
  let pause = pause.with(hider: draw.hide.with(bounds: true))
  ```
  Similarly, you can change the default hider functions to suit your package.
]

#slide[
  You can change the default `#hider` by using `#settings` functions, which will return a dictionary containing the functions:
  ```typc
  // import "@preview/cetz:0.4.1": canvas, draw
  let (uncover, pause) = settings(hider: draw.hide.with(bounds: true))
  ```
  For this change, the last example would become the
  #render-result(src2, title: [])
]

#let src3 = ```
#import "@preview/cetz:0.4.1": canvas, draw
#render(s => ({
  import animation: *
  canvas({
    import draw: *
    let (uncover, pause) = settings(hider: draw.hide.with(bounds: true))
    pause(s, circle((0, 0)))
    s.push(auto)
    uncover(s, 3,
      rect((-1, -1), (1, 1)))
    s.push((3,))
    only(s, 4, circle((1, 1)))
    s.push(4)
  })
}, s))
```

#slide[
  *Updating States*: In render function, the state variable `#s` is the sole information about the number of subslides needed to render all of the animations.

  #show: pause

  So updating it is crucial to produce the correct number of subslides. But how?

  #show: pause

  The state variable `s` is an _array_, so updating it is basically _push_ the new information to it. The infomation added determine the current animation states as

  #animate-items[
    - `#auto` is pushed to *increase the number of pauses by 1.*
  ][

    - `1, 2, 3, ..` intergers are pushed to set the *current number of pauses*.
  ][
    - `(1, 2,..)` array of integers are pushed to set the *minimum number of subslides*, _without_ updating pauses.
  ]
]

#slide[
  *Example 2*: CeTZ drawings with `#uncover` and `#only`
  #codly(highlighted-lines: (8, 11, 13))
  #columns(2, src3)
]
#slide[
  #utils.multicols((1fr, 1fr))[
    #render-result(src3)
  ][
    #set raw(lang: "typc")
    Notice that the circle produced by `only()` does not preserve space, as it uses `it => none` as hider.
  ]
  #show: pause

  The updates:
  The first `#auto` _increments_ the pauses, the second `#(3,)` set the _minimum subslides_ to at least 3 and `#4` set the number of _pauses_ to 4.

  #show: pause

  All you need to do is to update the `#s` for each animation.\
  For total number of subslides needed, Presentate will do the job _automatically_.
]

#let src4 = ```
#render(s => ({
  import animation: *
  diagram($
      pause(#s, A edge(->)) #s.push(auto)
        & pause(#s, B edge(->)) #s.push(auto)
          pause(#s, edge(->, "d") & C) \
        & pause(#s, D)
    $,)
}, s,))
```

#slide[
  *Example 3:* Fletcher in math mode diagram, with `it => none` as hider.
  #utils.multicols((30%, 1fr), align: top)[
    #render-result(src4)
    #show: pause
    Although not perfect, it is doable.
  ][
    #src4
  ]
]

#slide[Animate the inanimate][
  Last examples show us how to hack for drawing stuff that has its own `#hider`,
  either provided by the package or we created it.

  #show: pause
  However, I admitted that using `#pause(s, ..)` a lot is tedious, do we have a better way? #show: pause; How about making the input _reactive_ to the states?

  #show: pause
  Introducing `#animation.animate` function, together with a package for drawing molecular strcuture: #footlink("https://typst.app/universe/package/alchemist/")[Alchemist].
]

#slide[
  Alchemist does not provide any hider functions to hide the structure. However,
  we came up with an idea: setting the hidden bond's stroke to `#0pt` should effectively hide the bonds, right?

  #show: pause

  So we use the hider as a `#modifier` the function's argument.

  ```
  #import "@preview/alchemist:0.1.6": *
  #let (single,) = animation.animate(
    single, modifier: (func, ..args) => func(stroke: 0pt, ..args)
  )
  ```
  *Note!* The animated functions  require `#s` as the first positional argument.
]


#let src5 = ```
#render(s => ({
  skeletize({
    single(s) // Note the `s`!
    branch({
      s.push(auto)
      single(s, angle: -1)
    })
    s.push(auto)
    single(s, angle: 1)
  })
}, s))

```

#slide[
  #utils.multicols((1fr, 1fr))[
    #render-result(src5)
    #show: pause

    Now the molecule is drawn!\
    #show: pause
    The `#animate` is like _modifier_ to make the function
    _aware_ to the `#s` updates.
  ][
    #v(-1em)
    #src5
  ]
]

#slide[Modes and Utility][
  Presentate provides three modes for different purposes:
  #animate-items[
    - *Normal* for animated slides. [Default]
  ][
    - *Handout* for disabling all animations.
  ][
    - *Drafted* for showing the subslide number.
  ]
  #show: pause
  Normal mode is to do nothing, for the last two options, you can set them via
  ```
  #set-options(handout: true, drafted: true)
  ```
]


#slide[Themes][
  The slide you are viewing is the _simple_ theme of Presentate.
  You can use it by typing the following lines:
  ```
  #import themes.simple: *
  #show: template.with(
    author: [Pacaunt], // change to yours!
    title: [Welcome To Presentate!],
    subtitle: [Slides Tools.],
  )
  ```
]

#slide[
  The theme provides the following slides:
  - `#slide(title, body)` which if no title, it will repeat the last topic.

  - `#empty-slide(body)` which is empty and has no margin, header, and footer.

  - `#focus-slide(body)` which is colored, vibrant slide for getting attention.
  The preview is on the next slide:

]

#slide[
  #image("simple_theme.png")
]

#slide[
  #show: columns.with(2)
  ```
  = New Section
  #slide[Hello][
    This is Simple theme slide.
  ]

  #slide[
    Slide with no title will continue from the last title.
  ]

  #focus-slide[
    This should be focus!
  ]

  #empty-slide[
    #set align(center + horizon)
    `#empty-slide` is the slide with nothing, \
    even the `header` and `footer`.
  ]
  ```
]

#slide[
  Another theme is _default_ theme. It is very minimal, as it sets the paper and text font and sizes, provided with new section slides.

  #show: pause

  You can import it with

  ```
  #import themes.default: *
  #show: template.with(
    aspect-ratio: "16-9"
  )
  ```
  #show: pause
  and then you will have `#slide(body)`, which are normal slide function, and #box[`#empty-slide(body)`] for a slide with no header, footer, and margins.
]

#slide[
  Some example of the Default theme.
  #image("default_theme.png")
]

#slide[
  #show: block.with(height: 52%)
  #show: columns.with(2)
  ```
  = New Section

  #slide[
    == Hello
    This is default theme slide.
  ]

  #empty-slide[
    #set align(center + horizon)
    `#empty-slide` is the slide with nothing, \
    even the `header` and `footer`.
  ]
  ```
]

#slide[
  By default Presentate is still young and does not provide more themes currently, but the integration of Typst styling in Presentate should be seamless, and convenient enough to create by yourself :)
]

#empty-slide[
  #set align(center + horizon)
  For more information, you can contact us at \
  #link("https://github.com/pacaunt/typst-presentate/")[Presentate's github]\
  (#link("https://github.com/pacaunt/typst-presentate/"))

  Enjoy making presentation!
]
