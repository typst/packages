#let ergo-colors-names = read("./valid-schemes.txt").trim().split("\n") // generated by script
#let ergo-colors = (:)

// Initialize colors
#for colors-name in ergo-colors-names {
  ergo-colors.insert(colors-name, json("templates/" + colors-name + ".json"))
}

// Checks if dict is valid colorscheme
#let valid-colors(colors) = {
  if type(colors) != dictionary { return false }

  let proof-envs = (
    "theorem",
    "lemma",
    "corollary",
    "proposition",
    "problem",
    "exercise",
  )
  let statement-envs = (
    "note",
    "definition",
    "remark",
    "notation",
    "example",
    "concept",
    "computational-problem",
    "algorithm",
    "runtime",
  )

  let valid-color(env-colors, color-name) = {
    let color = env-colors.at(color-name, default: none)
    if type(color) != str or not color.starts-with("#") {
      return false
    }
    let hex-part = color.slice(1)
    let len = hex-part.len()
    if not (3, 4, 6, 8).contains(len) {
      return false
    }
    for c in hex-part {
      if not "0123456789abcdefABCDEF".contains(c) {
        return false
      }
    }
    return true
  }
  let valid-proof-colors(proof-colors) = {
    if type(proof-colors) != dictionary { return false }
    if (not valid-color(proof-colors, "bgcolor1") or
        not valid-color(proof-colors, "bgcolor2") or
        not valid-color(proof-colors, "strokecolor1") or
        not valid-color(proof-colors, "strokecolor2")) {
      return false
    }
    return true
  }
  let valid-statement-colors(statement-colors) = {
    if type(statement-colors) != dictionary { return false }
    if (not valid-color(statement-colors, "bgcolor") or
        not valid-color(statement-colors, "strokecolor")) {
      return false
    }
    return true
  }

  // Proof environments
  for proof-env in proof-envs {
    if not valid-proof-colors(colors.remove(proof-env, default: none)) {
      return false
    }
  }

  // Statement environments
  for statement-env in statement-envs {
    if not valid-statement-colors(colors.remove(statement-env, default: none)) {
      return false
    }
  }

  // Bookmark (technically statement struct)
  if not valid-statement-colors(colors.remove("bookmark", default: none)) {
    return false
  }

  // TODO: Raw
  let raw-setting = colors.remove("raw", default: none)
  if type(raw-setting) != dictionary { return false }

  // Verify optional arguments
  let opts-colors = colors.remove("opts", default: none)
  if type(opts-colors) == dictionary {
    for color-name in ("fill", "text1", "text2", "h1", "h2") {
      if opts-colors.at(color-name, default: none) == none { continue }
      if not valid-color(opts-colors, color-name) { return false }
    }
  }

  // Verify custom ids
  for (custom-name, custom-color) in colors {
    let custom-colors = colors.remove(custom-name, default: none)
    if type(custom-colors) != dictionary { return false }
    let custom-type = custom-colors.remove("type", default: none)

    if not ((custom-type == "proof" and
             valid-proof-colors(custom-colors)) or
            (custom-type == "statement" and
             valid-statement-colors(custom-colors))) {
      return false
    }
  }

  return true
}

// Calculates raw ratio based on float
#let get-ratio(colors, env-name, parameter-name) = {
  return float(colors.at(env-name).at(parameter-name)) * 100%
}

// Returns color dict of associated environment
#let get-colors(colors, env-name) = {
  return colors.at(env-name, default: none)
}

// Returns and possibly constructs "opts" color dict
#let get-opts-colors(colors) = {
  let opts = get-colors(colors, "opts")

  let filled-opts = (:)

  if (opts != none) {
    filled-opts.insert("fill",   opts.at("fill",   default: "#ffffff"))
    filled-opts.insert("text1",  opts.at("text1",  default: "#000000"))
    filled-opts.insert("text2",  opts.at("texcolors-dictt2",  default: "#ffffff"))
    filled-opts.insert("h1",     opts.at("h1",     default: "#020004"))
    filled-opts.insert("h2",     opts.at("h2",     default: "#16428e"))
    filled-opts.insert("strong", opts.at("strong", default: "#020004"))
  } else {
    filled-opts.insert("fill",   "#ffffff")
    filled-opts.insert("text1",  "#000000")
    filled-opts.insert("text2",  "#ffffff")
    filled-opts.insert("h1",     "#020004")
    filled-opts.insert("h2",     "#16428e")
    filled-opts.insert("strong", "#020004")
  }

  return filled-opts
}
